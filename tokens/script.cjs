const fs = require("fs");

const NAMESPACE = "org.twigma";
const PRIMITIVE_COLLECTION = "@primitive_color";
const SEMANTIC_COLLECTION = "@semantic_color";
const JOIN_CHAR = "_";
const SEMANTIC_MODES = { light: "day", dark: "night" };
const CSS_PRIMITIVE_PREFIX = "primitive-";
const CSS_SEMANTIC_PREFIX = "";

const data = JSON.parse(fs.readFileSync("./tokens/tokens.twigma.json"));
const primitive = data[PRIMITIVE_COLLECTION];
const semantic = data[SEMANTIC_COLLECTION];

const processed = { primitive: {}, semantic: {} };
traverse(processed.primitive, primitive, CSS_PRIMITIVE_PREFIX);
traverse(processed.semantic, semantic, CSS_SEMANTIC_PREFIX);

const fileString = `
/* 
 * This file is automatically generated by tokens/script.cjs! 
 */

:root {
  /* Primitives */
${processed.primitive.default
  .sort()
  .map((l) => `  ${l}`)
  .join(";\n")}
  
  /* Default Values (Light Mode) */
${processed.semantic[SEMANTIC_MODES.light]
  .sort()
  .map((l) => `  ${l}`)
  .join(";\n")}
}

@media (prefers-color-scheme: dark) {
  :root {
${processed.semantic[SEMANTIC_MODES.dark]
  .sort()
  .map((l) => `    ${l}`)
  .join(";\n")}
  }
}
`;
fs.writeFileSync("src/tokens.css", fileString);

// assumes everything is a color.
function traverse(definitions, object, prefix = "", keys = []) {
  if ("$value" in object) {
    if ("$extensions" in object && NAMESPACE in object.$extensions) {
      for (let mode in object.$extensions[NAMESPACE].modes) {
        definitions[mode] = definitions[mode] || [];
        definitions[mode].push(
          prefixKeysAndValueToDefinition(
            prefix,
            keys,
            valueToCSS(object.$extensions[NAMESPACE].modes[mode])
          )
        );
      }
    } else {
      const mode = "default";
      definitions[mode] = definitions[mode] || [];
      definitions[mode].push(
        prefixKeysAndValueToDefinition(prefix, keys, valueToCSS(object.$value))
      );
    }
  } else {
    Object.keys(object).forEach((k) => {
      if (k.charAt(0) !== "$") {
        traverse(definitions, object[k], [...keys, k]);
      }
    });
  }
}

function prefixKeysAndValueToDefinition(prefix, keys, value) {
  return `--${prefix}${keys.join("-")}: ${value}`;
}

function valueToCSS(value) {
  if (value.charAt(0) === "{")
    return `var(--${value
      .replace(PRIMITIVE_COLLECTION + JOIN_CHAR, CSS_PRIMITIVE_PREFIX)
      .replace(SEMANTIC_COLLECTION + JOIN_CHAR, CSS_SEMANTIC_PREFIX)
      .replace(/^\{/, "")
      .replace(/\}$/, "")})`;
  return value;
}
